# RhoPrime

ROOT-API for common physics analysis cases.

[Для ультра периферических взаимодействий(UPC)](https://arxiv.org/pdf/0706.3356.pdf)

Один из главных моментов в таком анализе:

> **В UPC события должны иметь слабый поперечный импульс, так как фотон, образующийся в процессе взаимодействия ядер, имеет слабый поперечный импульс**

_Далее, в заголовках, я буду выделять критерии, которые пытался наложить на события или треки, для изучения данных:_

## Поперечный импульс

Одним из главных параметров в анализе является поперечный импульс, так как, как правило, исследуемые частицы, являются результатом столкновения пучков, а значит разлетаются в поперечном направлении.

В нашем случае мы выделяем 4-х трековые события и построим распределения pt в зависимости от суммарного заряда треков:

## Псевдобыстрота

_[Код графиков](https://github.com/bdrum/analysis/blob/master/scripts/rho/src/psRapThetaPTracks.C)_

> **Псведобыстрота связана с полярным углом таким образом, что большой псевобыстрооте соответствуют маленькие $\theta$, которые, в свою очередь, соответствуют малому $p_t$ и наоборот.
> Таким образом критерий на псевдобыстроту так хорошо разделяет сигнал-фон.**

- Для $|pr| > 2$:
  ![PtRhoRapLT2](https://pp.userapi.com/c855620/v855620807/16321/AEOHc4TW8so.jpg)
- Для $|pr| < 2$:
  ![](https://pp.userapi.com/c855620/v855620807/16310/AEY5eOGOEE8.jpg)

Исследуем этот критерий подробнее:

Пределы псевдобыстроты от -1 до 1 соответствуют разрешению(acceptance) ALICE, так как acceptance детектора есть диапазон значений кинетических параметров частиц(главным образом $p_t, y$), что означает - потенциально только те частицы чьи параметры попадают в acceptance могут быть детектированы.

Распределение псевдобыстроты имеет вид:
![](https://pp.userapi.com/c846324/v846324915/1d267d/1Wpu4ZrURWQ.jpg)


## Триггеры

### 2015

CUP9
CUP8
###2018
CCUP29 veto v0 ad
CCUP30 = ccup29 + tof 2 hit
CCUP31 = ccup29 + tof 2 hit + back2back transversal plane
###periods
lhc18r 296690 - 297624
lhc18q 295581 - 296623

## Кластеры TPC

В TPC есть 18 секторов по 20 градусов, которые, таким образом, покрывают все 360 градусов.

**Кластер [TPC](http://nuclphys.sinp.msu.ru/experiment/detectors/tpc.htm)**. Релятивистская заряженная частица, пересекающая объём камеры, создает трек из ионизационных первичных и вторичных электронов − ионизационных кластеров. Кластер определяется по порожденному пролетом заряду:

Если заряд попадает в область из 5 (?) в направлении провода, 5 временных интервалов превышают заданный порог, а также выполняет все необходимые качественные критерии, в таком случае говорят о кластере.

_If the charge in a search window of 5 pads in wire direction and 5 bins in time direction exceeds a certain threshold and fulfills all necessary quality criteria, it is called a cluster._

Таким образом(?) максимальное число кластеров на трек - 160, что соответствует числу пэдов в секторе, при этом (сurling) части треков реконструируются в отдельные треки.

Распределение кластеров TPC: AliESDtrack::GetTPCNcls() на данных 2018 года LHC18q,r с триггером CUP31 выглядит следующим образом:
![](https://pp.userapi.com/c851336/v851336369/16602e/MtbJeYo6uQs.jpg)

Число класетров назначенное треку соответствует длине трека, в том смысле, что треки с маленьким $p_t$ не достигшие внешней границы TPC будут иметь меньше кластеров. Однако зависимост ь не прямая, так как длина пэда в TPC повышается с радиусом.


## Кластеры ITS

## Потери энергии

[//]: #$\large\frac{dE}{dx}$

## DCA

## Распределение по углу разлета

Идея этого критерия в том чтобы проверить в каких направлениях разлетаются частицы удовлетворяющие распаду (1)
Основываясь на условии по псевдобыстроте, можно посмотреть как распределены события сигнала и фона по углу:

Для **фона** распределение по азимуту выглядит следующим образом:
![](https://pp.userapi.com/c847016/v847016593/1dd978/yZQXaTDsX7o.jpg)
а для **сигнала**:
![](https://pp.userapi.com/c847016/v847016593/1dd98c/MAJ5woq9gyE.jpg)
Я ожидал увидеть здесь равномерное распределение для обоих случаев, однако, в случае фона распределение имеет иной, интересный вид, возможно имеет смысл изучить это подробнее.

Теперь попробуем посмотреть каким образом происходит разлет частиц в наших событиях, то есть построим количество треков летящих в противоположном направлении к первому треку в событиях с четыремя треками с нулевым суммарным зарядом. Например, в случае парного противоположного разлета (две частицы вверх две вниз) на гитсограмме такое событие будет соответствовать двум. И так далее:
Для $|pr| > 2$
![](https://pp.userapi.com/c855428/v855428134/161b4/fsKvZhAHhWo.jpg)

Для $|pr| < 2$
![](https://pp.userapi.com/c855428/v855428134/161be/mhRXJOgxo0Y.jpg)

Из гистограмм видно, что парность разлета не является необходимым условием для сигнала.

## V0

При отборе событий стояло условие на вето в V0. Поэтому на двух нижних графиках нули.
![](https://pp.userapi.com/c850016/v850016733/17f650/U8jdAPjKU1E.jpg)
![](https://pp.userapi.com/c850016/v850016733/17f658/5Z5YexcsLZk.jpg)

Распределение fAODVZero->GetV0ADecision()
![](https://pp.userapi.com/c850016/v850016733/17f660/2bHWiI0xNJk.jpg)

fAODVZero->GetV0CDecision();
![](https://pp.userapi.com/c850016/v850016733/17f668/Zaswy3kNqZA.jpg)

fAODVZero->GetNbPMV0A();
![](https://pp.userapi.com/c850016/v850016733/17f670/NWLlpVoLjps.jpg)

fAODVZero->GetNbPMV0C();
![](https://pp.userapi.com/c850016/v850016733/17f678/6-FxDE8cTN4.jpg)

Если для pt ко всем ограничениям добавить V0ADecision == 1
![](https://pp.userapi.com/c845219/v845219553/20aec9/ypNKzFor2sY.jpg)

Напомню, без этого условия поперечный импульс выглядит так:

![](https://pp.userapi.com/c850724/v850724553/11b804/zIqYaJTyHJg.jpg)

## Критерии отбора треков

В силу описанной выше реакции, нас интересуют 4-х трековые события, с сумарным зарядов 0, с условиями рефита в TPC и ITS, а также срабатывания 0 и первого слоя ITS. При этом количество слоев TPC должно быть меньше 50, так как дальше наша частица не долетит. Число сигм пиона орпеделенное в TPC более трех:

```cpp
//track condition
 if (!HasPointOnITSLayer0[i] && !HasPointOnITSLayer1[i]) continue;
 if (!StatusAndTPCRefit[i] && !StatusAndITSRefit[i]) continue;
 if (TPCNcls[i] < 50) continue;
 if (NumberOfSigmasTPCPion[i] > 3) continue;
 //event condition
 if (nGoodTracks != 4 || netCharge != 0) return -1.;
```

## Масса

В [статье](https://arxiv.org/pdf/0912.0604.pdf) STAR описано, что помимо 4-х трековых события выбирались также 2-х трековые и описан такой канал:
$$ \rho' \rightarrow \rho^0(770) f^0(660) \rightarrow [\pi^+\pi^-]_{P-Wave} [\pi^+\pi^-]_{S-Wave}$$

Указано, что такой распад является предположением для корректировок по разрешению(acceptance).
Интересно, что $f_0(600)$ - теперь [$f_0(500)$](http://pdg.lbl.gov/2019/listings/rpp2019-list-f0-500.pdf).

> TODO: Что это вообще такое - $f_0$?

[Описание техники PWA](https://github.com/bdrum/notes/blob/master/Physics/ParticlePhysics.md#Partial-Wave-Analysis)

Посмотрим на распределение инвариантных масс системы пионов в последнем канале с разбивкой на тяжелую и легкую пару с сумарным зарядом - 0:
![](https://pp.userapi.com/c853624/v853624467/484f3/T17ZuKYpbRo.jpg)

> Разбивка по массе, делается следующим образом:
>
> 1. Комбинируем всевозможные пары;
> 2. Сортируем по массе;
> 3. Берем первую пару;
> 4. Берем оставшуюся пару;

Важно отметить, что после взятия первой пары, у которой индекс может быть одним вариантом из множества:

```
{{0, 0}, {0, 1}, {1, 0}, {1, 1}}
```

оставшаяся пара будет иметь инвертированный индекс, который можно получить по принципу:

```
{abs(i-1), abs(j-1)},
```

где $i,j$ - индексы первой пары.

![](https://pp.userapi.com/c852020/v852020269/15ac06/FnLC8Zb_h-w.jpg)

![](https://pp.userapi.com/c852220/v852220269/159ff8/BBvhXXTPQ3E.jpg)

Масса четырех треков в сравнении:

- данные 2015 года с триггером CCUP8+CCUP9;
- данные 2015 года с триггером CCUP9;
- данные 2018 года с триггером cup29;
- данные 2018 года с триггером cup30;
- данные 2018 года с триггером cup31;

![](https://pp.userapi.com/c852028/v852028456/168a01/LrHNBLfEt5I.jpg)

TODO: Что можно сказать?
В данных cup31 добавился триггер на TOF, что сдвигает массу в сторону увеличения.

> **Еще один важный момент - не забывать про векторную природу величин.**

> _Проблема в том, что в статье считают так:
> берут первую пару с картинки, пусть это будет 1, остается 4. И масса этих пар как входы добавляется на гистограмму, то есть Fill(1.M), Fill(4.M). Так как в моем интерфейсе вызов Fill напрямую недопустим, я показывал сумму масс этих пар, что неправильно как и все картинки из прошлых версий.
> Для старых распределений провал до ~300МэВ как раз и был из-за суммирования значений масс, то есть ~300МэВ - сумма минимумов из набора масс пар треков._

> **Техническая деталь:**
> RDataFrame в случае когда с одного события надо вернуть два значения, похоже, не позволяет напрямую заполнить гистограмму. Таким образом придется через ForEach заполнять вектор, который затем класть в гистограмму.

TODO: Добавить про like sign, unlike sign

Пик в районе 0.5ГэВ - $K_0$

# $J/\Psi$

В случае если построить распределение массы $P_{wave}$ можно увидеть небольшое количество $J/\Psi$:

![](https://pp.userapi.com/c851336/v851336369/166041/3i43tc0UmIQ.jpg)


# $\Psi(2s)$

А если наложить ограничение на $M_{P_{wave}} \in [3, 3.2] GeV$
и построить распределение массы для 4 пронговых событий, то можно увидеть $\Psi(2s)$:
![](https://pp.userapi.com/c851336/v851336369/16604b/uGnGOWNDptc.jpg)


TODO: расписать процессы откуда берутся эти частицы
